#!/usr/bin/env python3
"""
Ethernaut Level 4: Telephone - Exploit Validator
=================================================
Validates the exploit for the tx.origin authentication vulnerability.

Usage:
    python3 validate_telephone.py

Author: Nova âœ¨
"""

import json
import sys
from dataclasses import dataclass, asdict
from typing import List
from enum import Enum
import os

class Status(Enum):
    PASS = "âœ… PASS"
    FAIL = "âŒ FAIL"
    SKIP = "â­ï¸  SKIP"
    PENDING = "â³ PENDING"

@dataclass
class TestResult:
    name: str
    status: Status
    details: str = ""
    
    def to_dict(self):
        return {
            "name": self.name,
            "status": self.status.value,
            "details": self.details
        }

@dataclass
class ExploitReport:
    level: int
    name: str
    results: List[TestResult]
    overall_status: Status
    notes: str = ""
    
    def to_dict(self):
        return {
            "level": self.level,
            "name": self.name,
            "overall_status": self.overall_status.value,
            "notes": self.notes,
            "tests": [r.to_dict() for r in self.results]
        }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LEVEL CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LEVEL_CONFIG = {
    "level": 4,
    "name": "Telephone",
    "difficulty": "Easy",
    "category": "Authentication",
    
    "vulnerability": """
    The contract uses tx.origin for authentication instead of msg.sender.
    tx.origin refers to the original EOA that initiated the transaction,
    while msg.sender refers to the immediate caller (can be a contract).
    When calling through a proxy contract, tx.origin != msg.sender.
    """,
    
    "exploit_approach": """
    1. Deploy TelephoneExploit contract with target address
    2. Call exploit() which calls changeOwner() on Telephone
    3. Telephone checks tx.origin (EOA) vs msg.sender (exploit contract)
    4. Since they differ, the owner is set to tx.origin (attacker's EOA)
    """,
    
    "prerequisites": [
        "Sepolia ETH for gas",
        "Telephone level instance deployed",
        "TelephoneExploit.sol compiled and deployed"
    ],
    
    "expected_behavior": {
        "initial_owner": "level_instance_address",
        "target_owner": "attacker_eoa_address",
        "auth_check": "tx.origin != msg.sender"
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TEST DEFINITIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def run_tests() -> List[TestResult]:
    """Define and run all validation tests for this level."""
    results = []
    
    # Test 1: Verify contract exists and vulnerability is present
    def test_vulnerability_exists() -> TestResult:
        """Check that the exploit contract exists and targets the vulnerability."""
        try:
            exploit_path = "04_telephone/TelephoneExploit.sol"
            if not os.path.exists(exploit_path):
                return TestResult(
                    name="Vulnerability Detection",
                    status=Status.FAIL,
                    details=f"Exploit contract not found at {exploit_path}"
                )
            
            with open(exploit_path, 'r') as f:
                content = f.read()
            
            # Check for key exploit components
            has_tx_origin = "tx.origin" in content
            has_change_owner = "changeOwner" in content
            has_target_interface = "ITelephone" in content
            
            if has_tx_origin and has_change_owner and has_target_interface:
                return TestResult(
                    name="Vulnerability Detection",
                    status=Status.PASS,
                    details="Exploit contract correctly targets tx.origin vulnerability"
                )
            else:
                return TestResult(
                    name="Vulnerability Detection",
                    status=Status.FAIL,
                    details=f"Missing components: tx.origin={has_tx_origin}, changeOwner={has_change_owner}"
                )
        except Exception as e:
            return TestResult(
                name="Vulnerability Detection",
                status=Status.FAIL,
                details=f"Error: {str(e)}"
            )
    
    # Test 2: Validate exploit logic
    def test_exploit_logic() -> TestResult:
        """Validate the exploit approach is sound."""
        try:
            exploit_path = "04_telephone/TelephoneExploit.sol"
            with open(exploit_path, 'r') as f:
                content = f.read()
            
            # Check for key exploit logic
            checks = {
                "constructor_sets_target": "target = ITelephone(_target)" in content,
                "constructor_sets_attacker": "attacker = msg.sender" in content,
                "exploit_calls_changeOwner": "target.changeOwner(attacker)" in content,
                "has_interface": "interface ITelephone" in content
            }
            
            passed = sum(checks.values())
            total = len(checks)
            
            if passed == total:
                return TestResult(
                    name="Exploit Logic Validation",
                    status=Status.PASS,
                    details=f"All {total} exploit components verified"
                )
            else:
                failed_checks = [k for k, v in checks.items() if not v]
                return TestResult(
                    name="Exploit Logic Validation",
                    status=Status.FAIL,
                    details=f"Failed checks: {', '.join(failed_checks)}"
                )
        except Exception as e:
            return TestResult(
                name="Exploit Logic Validation",
                status=Status.FAIL,
                details=f"Error: {str(e)}"
            )
    
    # Test 3: Check prerequisites
    def test_prerequisites() -> TestResult:
        """Verify all prerequisites are documented."""
        prereqs = LEVEL_CONFIG.get("prerequisites", [])
        if len(prereqs) >= 2:
            return TestResult(
                name="Prerequisites Check",
                status=Status.PASS,
                details=f"{len(prereqs)} prerequisites documented"
            )
        else:
            return TestResult(
                name="Prerequisites Check",
                status=Status.SKIP,
                details="Add more prerequisites for testnet execution"
            )
    
    # Test 4: Expected behavior validation
    def test_expected_behavior() -> TestResult:
        """Validate expected behavior configuration."""
        expected = LEVEL_CONFIG.get("expected_behavior", {})
        if expected and len(expected) >= 2:
            return TestResult(
                name="Expected Behavior Config",
                status=Status.PASS,
                details=f"Auth check: {expected.get('auth_check', 'N/A')}"
            )
        else:
            return TestResult(
                name="Expected Behavior Config",
                status=Status.SKIP,
                details="Add expected behavior metrics for validation"
            )
    
    # Test 5: Check contract compiles (simulated)
    def test_contract_compiles() -> TestResult:
        """Verify the Solidity contract is syntactically valid."""
        try:
            exploit_path = "04_telephone/TelephoneExploit.sol"
            with open(exploit_path, 'r') as f:
                content = f.read()
            
            # Basic syntax checks
            has_pragma = "pragma solidity" in content
            has_contract = "contract TelephoneExploit" in content
            valid_braces = content.count("{") == content.count("}")
            
            if has_pragma and has_contract and valid_braces:
                return TestResult(
                    name="Contract Syntax Check",
                    status=Status.PASS,
                    details="Solidity contract structure is valid"
                )
            else:
                return TestResult(
                    name="Contract Syntax Check",
                    status=Status.FAIL,
                    details=f"pragma={has_pragma}, contract={has_contract}, braces={valid_braces}"
                )
        except Exception as e:
            return TestResult(
                name="Contract Syntax Check",
                status=Status.FAIL,
                details=f"Error: {str(e)}"
            )
    
    # Run all tests
    results.append(test_vulnerability_exists())
    results.append(test_exploit_logic())
    results.append(test_prerequisites())
    results.append(test_expected_behavior())
    results.append(test_contract_compiles())
    
    return results

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# REPORT GENERATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def generate_report(results: List[TestResult]) -> ExploitReport:
    """Generate final report from test results."""
    passed = sum(1 for r in results if r.status == Status.PASS)
    failed = sum(1 for r in results if r.status == Status.FAIL)
    skipped = sum(1 for r in results if r.status == Status.SKIP)
    
    if failed == 0 and passed >= 4:
        overall = Status.PASS
    elif failed == 0 and passed >= 2:
        overall = Status.PENDING
    else:
        overall = Status.FAIL
    
    notes = f"Tests: {passed} passed, {failed} failed, {skipped} skipped"
    
    return ExploitReport(
        level=LEVEL_CONFIG["level"],
        name=LEVEL_CONFIG["name"],
        results=results,
        overall_status=overall,
        notes=notes
    )

def print_report(report: ExploitReport):
    """Print formatted report to console."""
    print("\n" + "=" * 70)
    print(f"ğŸ¯ Ethernaut Level {report.level}: {report.name}")
    print("=" * 70)
    print(f"Difficulty: {LEVEL_CONFIG['difficulty']} | Category: {LEVEL_CONFIG['category']}")
    print("-" * 70)
    
    for result in report.results:
        print(f"\n{result.status.value} â€” {result.name}")
        if result.details:
            print(f"   {result.details}")
    
    print("\n" + "-" * 70)
    print(f"Overall Status: {report.overall_status.value}")
    print(f"Notes: {report.notes}")
    print("=" * 70 + "\n")

def save_report(report: ExploitReport, filename: str = None):
    """Save report to JSON file."""
    if filename is None:
        filename = f"reports/level_{report.level}_{report.name.lower()}.json"
    
    os.makedirs(os.path.dirname(filename), exist_ok=True)
    
    with open(filename, 'w') as f:
        json.dump(report.to_dict(), f, indent=2)
    
    print(f"ğŸ“„ Report saved to: {filename}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN ENTRY POINT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    print(f"ğŸš€ Validating Ethernaut Level {LEVEL_CONFIG['level']}: {LEVEL_CONFIG['name']}")
    
    # Run all tests
    results = run_tests()
    
    # Generate report
    report = generate_report(results)
    
    # Print to console
    print_report(report)
    
    # Save to file
    save_report(report)
    
    # Exit with appropriate code
    if report.overall_status == Status.FAIL:
        sys.exit(1)
    elif report.overall_status == Status.PENDING:
        sys.exit(0)
    else:
        sys.exit(0)

if __name__ == "__main__":
    main()
