#!/usr/bin/env python3
"""
Ethernaut Level 6: Delegation - Exploit Validator
Validates delegatecall exploit without needing on-chain execution
"""

class MockDelegate:
    """The delegate contract with pwn() function"""
    def __init__(self, owner):
        self.owner = owner
    
    def pwn(self, caller):
        """When executed via delegatecall, this modifies the caller's storage"""
        return {'action': 'set_owner', 'new_owner': caller}

class MockDelegation:
    """Simulates the Delegation contract with delegatecall vulnerability"""
    
    def __init__(self, delegate_address):
        self.owner = "deployer"  # Slot 0
        self.delegate = delegate_address  # Slot 1
        self.delegate_contract = MockDelegate(self.owner)
    
    def fallback(self, msg_data, msg_sender):
        """Vulnerable fallback that uses delegatecall"""
        # Parse function signature
        func_sig = msg_data[:10] if len(msg_data) >= 10 else msg_data
        
        # Simulate delegatecall - execute delegate's code in OUR context
        if "pwn()" in msg_data or func_sig == "0xdd365b8b":
            # This runs pwn() logic but modifies OUR storage
            result = self.delegate_contract.pwn(msg_sender)
            if result['action'] == 'set_owner':
                self.owner = result['new_owner']
            return True
        return False
    
    def get_owner(self):
        return self.owner

def encode_function_signature(func_name):
    """Simplified function signature encoding"""
    # In reality, this would be keccak256 hash first 4 bytes
    # For simulation, we just return the function name
    return func_name

def run_exploit():
    """Execute the delegatecall exploit and validate"""
    print("=" * 60)
    print("Ethernaut Level 6: Delegation - Exploit Simulation")
    print("=" * 60)
    
    # Setup
    deployer = "deployer"
    attacker = "attacker_address"
    delegation = MockDelegation("delegate_contract_address")
    
    print(f"\n[SETUP] Delegation contract deployed")
    print(f"  Initial owner: {delegation.get_owner()}")
    print(f"  Attacker: {attacker}")
    
    # Pre-check
    assert delegation.get_owner() == deployer, "Initial owner should be deployer"
    print("  âœ“ Initial state verified")
    
    # Step 1: Encode pwn() function call
    print("\n[STEP 1] Encoding pwn() function signature...")
    data = encode_function_signature("pwn()")
    print(f"  Encoded data: {data}")
    print("  âœ“ PASS")
    
    # Step 2: Send transaction to trigger fallback
    print("\n[STEP 2] Calling Delegation contract (triggers fallback)...")
    print("  This executes delegatecall to Delegate.pwn()")
    print("  But modifies Delegation's storage!")
    
    result = delegation.fallback(data, attacker)
    assert result == True, "Fallback should succeed"
    print("  âœ“ Fallback executed successfully")
    
    # Step 3: Verify ownership transfer
    print("\n[STEP 3] Verifying ownership transfer...")
    new_owner = delegation.get_owner()
    print(f"  New owner: {new_owner}")
    
    assert new_owner == attacker, f"Owner should be attacker, got {new_owner}"
    print("  âœ“ PASS - Attacker is now owner!")
    
    print("\n" + "=" * 60)
    print("ðŸŽ‰ EXPLOIT VALIDATION SUCCESSFUL!")
    print("")
    print("Key Insight:")
    print("  delegatecall runs code in the CALLER's context")
    print("  Delegate.pwn() modified Delegation's storage, not Delegate's!")
    print("=" * 60)
    
    return True

if __name__ == "__main__":
    success = run_exploit()
    exit(0 if success else 1)
