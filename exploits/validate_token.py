#!/usr/bin/env python3
"""
Ethernaut Level 5: Token - Exploit Validator
=============================================
Validates the exploit for the integer underflow vulnerability.

Usage:
    python3 validate_token.py

Author: Nova âœ¨
"""

import json
import sys
from dataclasses import dataclass, asdict
from typing import List
from enum import Enum
import os

class Status(Enum):
    PASS = "âœ… PASS"
    FAIL = "âŒ FAIL"
    SKIP = "â­ï¸  SKIP"
    PENDING = "â³ PENDING"

@dataclass
class TestResult:
    name: str
    status: Status
    details: str = ""
    
    def to_dict(self):
        return {
            "name": self.name,
            "status": self.status.value,
            "details": self.details
        }

@dataclass
class ExploitReport:
    level: int
    name: str
    results: List[TestResult]
    overall_status: Status
    notes: str = ""
    
    def to_dict(self):
        return {
            "level": self.level,
            "name": self.name,
            "overall_status": self.overall_status.value,
            "notes": self.notes,
            "tests": [r.to_dict() for r in self.results]
        }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LEVEL CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LEVEL_CONFIG = {
    "level": 5,
    "name": "Token",
    "difficulty": "Easy",
    "category": "Integer Overflow/Underflow",
    
    "vulnerability": """
    The contract uses Solidity 0.6 which doesn't check for integer underflow.
    The line `require(balances[msg.sender] - _value >= 0)` looks safe but isn't.
    When subtracting a larger number from a smaller uint, it underflows to max uint256.
    This bypasses the check and gives the attacker infinite tokens.
    """,
    
    "exploit_approach": """
    1. Start with 20 tokens (given by the level)
    2. Call transfer() with _value = 21 (more than balance)
    3. 20 - 21 underflows to 2^256 - 1 (massive number)
    4. The require() check passes because result >= 0
    5. Balance becomes ~infinite tokens
    """,
    
    "prerequisites": [
        "Sepolia ETH for gas",
        "Token level instance deployed",
        "TokenExploit.sol compiled and deployed"
    ],
    
    "expected_behavior": {
        "initial_balance": 20,
        "transfer_amount": 21,
        "expected_final_balance": "2^256 - 1 (underflow)",
        "vulnerability_type": "integer_underflow"
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TEST DEFINITIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def run_tests() -> List[TestResult]:
    """Define and run all validation tests for this level."""
    results = []
    
    # Test 1: Verify contract exists and vulnerability is present
    def test_vulnerability_exists() -> TestResult:
        """Check that the exploit contract exists and targets the vulnerability."""
        try:
            exploit_path = "05_token/TokenExploit.sol"
            if not os.path.exists(exploit_path):
                return TestResult(
                    name="Vulnerability Detection",
                    status=Status.FAIL,
                    details=f"Exploit contract not found at {exploit_path}"
                )
            
            with open(exploit_path, 'r') as f:
                content = f.read()
            
            # Check for key exploit components
            has_transfer = "transfer(" in content
            has_underflow_amount = "21" in content  # Amount > 20 to trigger underflow
            has_interface = "IToken" in content
            
            if has_transfer and has_underflow_amount and has_interface:
                return TestResult(
                    name="Vulnerability Detection",
                    status=Status.PASS,
                    details="Exploit contract correctly targets integer underflow"
                )
            else:
                return TestResult(
                    name="Vulnerability Detection",
                    status=Status.FAIL,
                    details=f"Missing components: transfer={has_transfer}, amount={has_underflow_amount}"
                )
        except Exception as e:
            return TestResult(
                name="Vulnerability Detection",
                status=Status.FAIL,
                details=f"Error: {str(e)}"
            )
    
    # Test 2: Validate exploit logic
    def test_exploit_logic() -> TestResult:
        """Validate the exploit approach is sound."""
        try:
            exploit_path = "05_token/TokenExploit.sol"
            with open(exploit_path, 'r') as f:
                content = f.read()
            
            # Check for key exploit logic
            checks = {
                "constructor_sets_target": "target = IToken(_target)" in content,
                "constructor_sets_attacker": "attacker = msg.sender" in content,
                "exploit_calls_transfer": "target.transfer(" in content,
                "transfer_amount_21": "21" in content,
                "has_interface": "interface IToken" in content,
                "has_balanceOf": "balanceOf(" in content
            }
            
            passed = sum(checks.values())
            total = len(checks)
            
            if passed == total:
                return TestResult(
                    name="Exploit Logic Validation",
                    status=Status.PASS,
                    details=f"All {total} exploit components verified"
                )
            else:
                failed_checks = [k for k, v in checks.items() if not v]
                return TestResult(
                    name="Exploit Logic Validation",
                    status=Status.FAIL,
                    details=f"Failed checks: {', '.join(failed_checks)}"
                )
        except Exception as e:
            return TestResult(
                name="Exploit Logic Validation",
                status=Status.FAIL,
                details=f"Error: {str(e)}"
            )
    
    # Test 3: Check prerequisites
    def test_prerequisites() -> TestResult:
        """Verify all prerequisites are documented."""
        prereqs = LEVEL_CONFIG.get("prerequisites", [])
        if len(prereqs) >= 2:
            return TestResult(
                name="Prerequisites Check",
                status=Status.PASS,
                details=f"{len(prereqs)} prerequisites documented"
            )
        else:
            return TestResult(
                name="Prerequisites Check",
                status=Status.SKIP,
                details="Add more prerequisites for testnet execution"
            )
    
    # Test 4: Expected behavior validation
    def test_expected_behavior() -> TestResult:
        """Validate expected behavior configuration."""
        expected = LEVEL_CONFIG.get("expected_behavior", {})
        if expected and len(expected) >= 3:
            return TestResult(
                name="Expected Behavior Config",
                status=Status.PASS,
                details=f"Underflow: {expected.get('transfer_amount', 'N/A')} > {expected.get('initial_balance', 'N/A')}"
            )
        else:
            return TestResult(
                name="Expected Behavior Config",
                status=Status.SKIP,
                details="Add expected behavior metrics for validation"
            )
    
    # Test 5: Check contract compiles (simulated)
    def test_contract_compiles() -> TestResult:
        """Verify the Solidity contract is syntactically valid."""
        try:
            exploit_path = "05_token/TokenExploit.sol"
            with open(exploit_path, 'r') as f:
                content = f.read()
            
            # Basic syntax checks
            has_pragma = "pragma solidity" in content
            has_contract = "contract TokenExploit" in content
            valid_braces = content.count("{") == content.count("}")
            
            if has_pragma and has_contract and valid_braces:
                return TestResult(
                    name="Contract Syntax Check",
                    status=Status.PASS,
                    details="Solidity contract structure is valid"
                )
            else:
                return TestResult(
                    name="Contract Syntax Check",
                    status=Status.FAIL,
                    details=f"pragma={has_pragma}, contract={has_contract}, braces={valid_braces}"
                )
        except Exception as e:
            return TestResult(
                name="Contract Syntax Check",
                status=Status.FAIL,
                details=f"Error: {str(e)}"
            )
    
    # Run all tests
    results.append(test_vulnerability_exists())
    results.append(test_exploit_logic())
    results.append(test_prerequisites())
    results.append(test_expected_behavior())
    results.append(test_contract_compiles())
    
    return results

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# REPORT GENERATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def generate_report(results: List[TestResult]) -> ExploitReport:
    """Generate final report from test results."""
    passed = sum(1 for r in results if r.status == Status.PASS)
    failed = sum(1 for r in results if r.status == Status.FAIL)
    skipped = sum(1 for r in results if r.status == Status.SKIP)
    
    if failed == 0 and passed >= 4:
        overall = Status.PASS
    elif failed == 0 and passed >= 2:
        overall = Status.PENDING
    else:
        overall = Status.FAIL
    
    notes = f"Tests: {passed} passed, {failed} failed, {skipped} skipped"
    
    return ExploitReport(
        level=LEVEL_CONFIG["level"],
        name=LEVEL_CONFIG["name"],
        results=results,
        overall_status=overall,
        notes=notes
    )

def print_report(report: ExploitReport):
    """Print formatted report to console."""
    print("\n" + "=" * 70)
    print(f"ğŸ¯ Ethernaut Level {report.level}: {report.name}")
    print("=" * 70)
    print(f"Difficulty: {LEVEL_CONFIG['difficulty']} | Category: {LEVEL_CONFIG['category']}")
    print("-" * 70)
    
    for result in report.results:
        print(f"\n{result.status.value} â€” {result.name}")
        if result.details:
            print(f"   {result.details}")
    
    print("\n" + "-" * 70)
    print(f"Overall Status: {report.overall_status.value}")
    print(f"Notes: {report.notes}")
    print("=" * 70 + "\n")

def save_report(report: ExploitReport, filename: str = None):
    """Save report to JSON file."""
    if filename is None:
        filename = f"reports/level_{report.level}_{report.name.lower()}.json"
    
    os.makedirs(os.path.dirname(filename), exist_ok=True)
    
    with open(filename, 'w') as f:
        json.dump(report.to_dict(), f, indent=2)
    
    print(f"ğŸ“„ Report saved to: {filename}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN ENTRY POINT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    print(f"ğŸš€ Validating Ethernaut Level {LEVEL_CONFIG['level']}: {LEVEL_CONFIG['name']}")
    
    # Run all tests
    results = run_tests()
    
    # Generate report
    report = generate_report(results)
    
    # Print to console
    print_report(report)
    
    # Save to file
    save_report(report)
    
    # Exit with appropriate code
    if report.overall_status == Status.FAIL:
        sys.exit(1)
    elif report.overall_status == Status.PENDING:
        sys.exit(0)
    else:
        sys.exit(0)

if __name__ == "__main__":
    main()
