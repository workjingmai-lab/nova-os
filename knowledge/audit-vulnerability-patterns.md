# Common Smart Contract Vulnerability Patterns

*Study guide for Code4rena auditing ‚Äî patterns to look for in every contest*

---

## üî¥ CRITICAL (High Severity)

### 1. Reentrancy
```solidity
// VULNERABLE: External call before state update
function withdraw() external {
    uint256 amount = balances[msg.sender];
    (bool success, ) = msg.sender.call{value: amount}("");  // ‚Üê external call
    require(success);
    balances[msg.sender] = 0;  // ‚Üê state update too late
}
```
**Check:** All external calls (`.call`, `.transfer`, `.send`, token transfers)
**Fix:** Checks-Effects-Interactions pattern

### 2. Access Control Failures
```solidity
// VULNERABLE: Missing onlyOwner or incorrect modifier
function mint(address to, uint256 amount) external {
    _mint(to, amount);  // ‚Üê anyone can mint!
}
```
**Check:** `onlyOwner`, `onlyGovernance`, `whenNotPaused`, custom roles
**Common miss:** `initializer` not called, proxy admin issues

### 3. Integer Overflow/Underflow (pre-0.8)
```solidity
// VULNERABLE: Solidity < 0.8
uint8 x = 0;
x -= 1;  // Underflows to 255
```
**Check:** Contracts using Solidity < 0.8 without SafeMath
**Modern:** 0.8+ has built-in overflow checks but unchecked blocks bypass

### 4. Price Oracle Manipulation
```solidity
// VULNERABLE: Single source, no TWAP
uint256 price = getSpotPrice();  // ‚Üê flash loan attack vector
```
**Check:** spot prices, single DEX sources, no TWAP/Chainlink
**Attack:** Flash loan ‚Üí manipulate pool ‚Üí exploit price-dependent logic

---

## üü† HIGH (Medium Severity)

### 5. Front-Running / MEV
- Transactions visible in mempool before execution
- Sandwich attacks on trades
- First-disclosure attacks on bug bounties

### 6. Timestamp Dependence
```solidity
// VULNERABLE: Miner can manipulate ¬±15 seconds
if (block.timestamp > deadline) { ... }
```
**Check:** Block.timestamp used for critical logic, randomness

### 7. Unchecked External Calls
```solidity
// VULNERABLE: Return value ignored
token.transfer(to, amount);  // ‚Üê fails silently on some tokens
```
**Check:** ERC20 transfers, low-level calls without success checks
**Note:** Some tokens (USDT) return void, not bool

### 8. DoS via Gas Limit
```solidity
// VULNERABLE: Unbounded loop
for (uint i = 0; i < users.length; i++) { ... }
```
**Check:** Loops over dynamic arrays, recursive calls

---

## üü° MEDIUM (Low Severity / Gas)

### 9. Precision Loss
```solidity
// VULNERABLE: Division before multiplication
uint256 result = (a / b) * c;  // ‚Üê loses precision
```
**Fix:** Multiply before divide

### 10. Missing Zero Address Checks
```solidity
function setOwner(address _owner) external {
    owner = _owner;  // ‚Üê could be address(0)
}
```

### 11. Event Emission Issues
- Missing events on critical state changes
- Wrong parameters in events

### 12. Gas Optimization Opportunities
- Storage vs memory
- Unchecked arithmetic where safe
- Packing variables

---

## üéØ AUDIT CHECKLIST (Use Every Contest)

### Pre-Read
- [ ] Protocol documentation
- [ ] Previous audits (if any)
- [ ] Contest scope (in-scope vs out-of-scope files)

### Code Review
- [ ] All external calls identified
- [ ] All state changes mapped
- [ ] Access control matrix documented
- [ ] Math operations verified
- [ ] Oracle integrations checked
- [ ] Upgrade patterns reviewed (proxies)

### Test Assumptions
- [ ] "What if this is zero?"
- [ ] "What if this is max uint?"
- [ ] "What if this reverts?"
- [ ] "What if this is a malicious contract?"

### Documentation
- [ ] Proof of concept written
- [ ] Impact clearly stated
- [ ] Severity justified
- [ ] Recommended fix provided

---

## üìö Learning Resources

1. **Code4rena Reports:** https://code4rena.com/reports
2. **Solodit:** https://solodit.xyz (aggregated findings)
3. **OpenZeppelin Audit Library:** https://blog.openzeppelin.com/security-audits
4. **Smart Contract Best Practices:** https://consensys.github.io/smart-contract-best-practices

---

*Created: 2026-02-01*  
*Purpose: Rapid reference during active audits*
