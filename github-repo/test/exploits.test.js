const { expect } = require('chai');
const { ethers } = require('hardhat');

describe('Ethernaut Exploits', function () {
  let player, target, exploit;

  beforeEach(async function () {
    [player] = await ethers.getSigners();
  });

  describe('Fallback Challenge', function () {
    it('Should claim ownership via fallback', async function () {
      // Deploy target
      const Fallback = await ethers.getContractFactory('Fallback');
      target = await Fallback.deploy();
      await target.deployed();

      // Deploy and execute exploit
      const FallbackExploit = await ethers.getContractFactory('FallbackExploit');
      exploit = await FallbackExploit.deploy(target.address);
      await exploit.deployed();

      // Execute attack
      await exploit.attack({ value: ethers.utils.parseEther('0.0002') });

      // Verify ownership
      expect(await target.owner()).to.equal(player.address);
    });
  });

  describe('Reentrancy Challenge', function () {
    it('Should drain contract via reentrancy', async function () {
      // Deploy target with 1 ETH
      const Reentrance = await ethers.getContractFactory('Reentrance');
      target = await Reentrance.deploy();
      await target.deployed();
      await player.sendTransaction({
        to: target.address,
        value: ethers.utils.parseEther('1')
      });

      // Deploy exploit
      const ReentrancyExploit = await ethers.getContractFactory('ReentrancyExploit');
      exploit = await ReentrancyExploit.deploy(target.address);
      await exploit.deployed();

      // Execute attack
      const depositAmount = ethers.utils.parseEther('0.001');
      await exploit.attack({ value: depositAmount });

      // Verify drain
      const targetBalance = await ethers.provider.getBalance(target.address);
      expect(targetBalance).to.equal(0);

      const stolenBalance = await exploit.getBalance();
      expect(stolenBalance).to.be.gt(depositAmount);
    });
  });
});
