#!/usr/bin/env python3
"""Create a sanitized, publishable static `public/` bundle.

Design goals:
- Safe-by-default: copy ONLY allowlisted paths.
- Minimal: intended for GitHub Pages / Netlify static hosting.

Usage:
  python3 tools/public-export.py
  python3 tools/public-export.py --out public/
  python3 tools/public-export.py --allowlist tools/public-allowlist.txt

It creates/overwrites the output directory.
"""

from __future__ import annotations

import argparse
import re
import shutil
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]

# Keep this list tight. Add paths intentionally.
DEFAULT_ALLOWLIST = [
    "index.html",
    "README.md",
    "PORTFOLIO.md",
    "toolkit.md",
    "EARNING-STRATEGY.md",
    "dashboard",
    "reports",
]

# Basic redactions if you decide to publish markdown that might contain secrets.
REDACTIONS = [
    # Generic token-looking strings
    (re.compile(r"(?i)(authorization: bearer)\s+[A-Za-z0-9_\-\.]+"), r"\\1 [REDACTED]"),
    (re.compile(r"(?i)\b(sk|pk|api)_?[A-Za-z0-9]{16,}\b"), "[REDACTED]"),
    (re.compile(r"(?i)\b(bearer)\s+[A-Za-z0-9_\-\.]{16,}\b"), r"\\1 [REDACTED]"),
]

TEXT_EXTS = {".md", ".txt", ".html", ".json", ".js", ".css"}


def is_text_file(p: Path) -> bool:
    return p.suffix.lower() in TEXT_EXTS


def load_allowlist(path: Path | None) -> list[str]:
    if path is None:
        return list(DEFAULT_ALLOWLIST)

    data = path.read_text(encoding="utf-8").splitlines()
    out: list[str] = []
    for line in data:
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        out.append(line)
    return out


def copy_path(out_dir: Path, rel: str) -> None:
    src = ROOT / rel
    dst = out_dir / rel

    if not src.exists():
        print(f"[skip] missing: {rel}")
        return

    if src.is_dir():
        if dst.exists():
            shutil.rmtree(dst)
        shutil.copytree(src, dst, dirs_exist_ok=True)
    else:
        dst.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(src, dst)


def redact_in_place(out_dir: Path, p: Path) -> None:
    try:
        data = p.read_text(encoding="utf-8")
    except Exception:
        return
    orig = data
    for rx, repl in REDACTIONS:
        data = rx.sub(repl, data)
    if data != orig:
        p.write_text(data, encoding="utf-8")
        print(f"[redact] {p.relative_to(out_dir)}")


def main() -> int:
    ap = argparse.ArgumentParser(description="Export a sanitized allowlisted public bundle")
    ap.add_argument("--out", default=str(ROOT / "public"), help="Output directory (default: ./public)")
    ap.add_argument(
        "--allowlist",
        default=None,
        help=(
            "Path to allowlist file (one path per line; # comments). "
            "Tip: start from tools/public-allowlist.txt. Defaults to built-in list."
        ),
    )
    args = ap.parse_args()

    out_dir = Path(args.out).expanduser().resolve()
    allowlist = load_allowlist(Path(args.allowlist).expanduser().resolve() if args.allowlist else None)

    out_dir.mkdir(parents=True, exist_ok=True)

    # Clean output, but ONLY inside out_dir
    for child in list(out_dir.iterdir()):
        if child.is_dir():
            shutil.rmtree(child)
        else:
            child.unlink()

    for rel in allowlist:
        copy_path(out_dir, rel)

    # Redact text files in-place
    for p in out_dir.rglob("*"):
        if p.is_file() and is_text_file(p):
            redact_in_place(out_dir, p)

    # Add a tiny publish note
    (out_dir / "PUBLIC_EXPORT.md").write_text(
        """# Public Export\n\nThis folder is generated by `tools/public-export.py`.\n\nIt intentionally includes only a small allowlist of files/directories and performs light redactions.\nIf you want to publish, deploy *this* folder (not the whole repo).\n""",
        encoding="utf-8",
    )

    print(f"\nDone. Exported -> {out_dir}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
